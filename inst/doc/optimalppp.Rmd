---
title: "Optimal Project Prioritization Protocol"
output:
  rmarkdown::html_vignette:
    toc: true
    fig_caption: true
    self_contained: yes
fontsize: 11pt
bibliography: references.bib
csl: reference-style.csl
documentclass: article
vignette: >
  %\VignetteIndexEntry{optimalppp}
  %\VignetteEngine{knitr::rmarkdown_notangle}
---

```{r, include = FALSE}
# define fig sizes
fw <- 7.0
fh <- 4.5

# disable running vignette code during R CMD check
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
             "_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
knitr::opts_chunk$set(fig.align = "center", eval = !is_check)

# create default objects
s1 <- data.frame(objective = 1)
s2 <- data.frame(objective = 1)
s3 <- data.frame(objective = 1)
s4 <- data.frame(objective = 1)
```

## Overview

The _optimalppp R_ package provides methods for prioritizing funding of conservation projects using the 'Protect Prioritization Protocol'. Projects can be prioritized by maximizing expected species richness or expected phylogenetic diversity. Prioritizations can be generated using a range of methods, such as exact algorithms which can identify optimal solutions, heuristic algorithms which have conventionally been used to identify solutions, and by randomly funding projects. This package also provides the functionality to visualize how well solutions maintain biodiversity.

## Tutorial

Here we will provide a short example showing how the _optimalppp R_ package can be used to prioritize funding for conservation projects. With limited resources available for conservation [@r2], it is imperative that funds are prioritized for conservation projects which will create the best outcome. This realization led to development of the 'Project Prioritization Protocol' [@r3]. This method, broadly speaking, involves evaluating conservation projects according to (i) the probability that they are expected to succeed, (ii) the probability that species will persist if their projects are funded and successful, and (iii) a metric describing the value of the conserved species [evaluated in @r4]. Since its inception, project prioritization has diverged into 'species prioritization' [e.g. @r4], where each conservation project corresponds to a different species, and 'priority threat management prioritization' [@r5], where each conservation project pertains to a different threat which can affect multiple species. Here we do not differentiate between these types of problems---the _optimalppp R_ package solves a general mathematical formulation that can handle both classes of problems.

The _optimalppp R_ package provides two metrics for prioritizing and evaluating conservation projects. Firstly, prioritizations can be generated by maximizing 'expected weighted species richness'. This metric is simply the sum of the species' probabilities of persistence multiplied by weights (e.g. based on cultural importance or evolutionary significance) [e.g. @r11]. Secondly, prioritizations can be generated by maximizing 'expected phylogenetic diversity' [@r9; @r8]. This metric uses phylogenetic data to quantify the amount of evolutionary history that is expected to persist into the future. Based on these metrics, prioritizations can be generated under a fixed budget by using exact algorithms (via the [Gurobi optimization suite](http://gurobi.com/)), heuristic algorithms [similar to @r4], and random processes.

### Data simulation

To start off, we will set the seed for the random number generator to ensure reproducibility, load the _optimalppp R_ package, and load the _ggtree R_ package to plot phylogenetic trees. Please note that you will need install the _ggtree_ separately from Bioconductor since it is not available on The Comprehensive R Archive Network (CRAN). This can be achieved with the following command `source("https://bioconductor.org/biocLite.R");biocLite("ggtree")`.

```{r, eval = FALSE}
set.seed(700)
library(optimalppp)
library(ggtree)
```

```{r, include = FALSE}
set.seed(700)
library(optimalppp)
library(ggtree)
```

Now we will simulate a data set. This data set will contain conservation projects and conservation actions for 50 species. It will also species weight data. And also phylogenetic data that describe the evolutionary relationships between them. To learn more about what these parameters mean, check out `?ppp_simulate_data`.

```{r}
# set simulation parameters
number_species <- 50
cost_mean <- 100
cost_sd <- 5
success_min_probability <- 0.7
success_max_probability <- 0.99
funded_min_persistence_probability <- 0.5
funded_max_persistence_probability <- 0.9
not_funded_min_persistence_probability <- 0.01
not_funded_max_persistence_probability <- 0.4
locked_in_proportion <- 0.1
locked_out_proportion <- 0.1

# simulate data
sim <- ppp_simulate_data(number_species,
                         cost_mean,
                         cost_sd,
                         success_min_probability,
                         success_max_probability,
                         funded_min_persistence_probability,
                         funded_max_persistence_probability,
                         not_funded_min_persistence_probability,
                         not_funded_max_persistence_probability,
                         locked_in_proportion,
                         locked_out_proportion)

# extract the data
project_data <- sim$project_data
action_data <- sim$action_data
species_data <- sim$species_data
tree <- sim$tree
```

Now let's examine the simulated data. Let's look at the `action_data` object. This object stores information about various conservation actions in a tabular format (i.e. `tibble`). Each row corresponds to a different action, and each column describes different properties associated with the actions. These actions correspond to specific management actions that have known costs. For example, they may relate to baiting or trapping sites of conservation importance. In this table, the `"name"` column contains the name of each action, and the `"cost"` action denotes the cost of funding each project. It also contains additional columns for customizing the solutions, but we will ignore them for now. Note that the last project---the `"baseline_action"`---has a zero cost and is used subsequently to represent the baseline probability for species when no conservation actions are funded for them.

```{r}
# preview first six rows of the table
head(as.data.frame(action_data))
```

Next, let's examine the `project_data` object. This object stores information about various conservation projects in a tabular format (i.e. `tibble`). Each row corresponds to a different project, and each column describes various properties associated with the projects. These projects correspond to groups of conservation actions. For example, a conservation project may pertain to a set of conservation actions that relate to a single species or single geographic locality. In this table, the `"name"` column contains the name of each project, the `"success"` column denotes the probability of each project succeeding if it is funded, the `"S1"`--`"SN"` columns show the enhanced probability of each species persisting if the project is funded, and the `"S1_action"`--`"SN_action"` columns indicate which actions are associated with which project.  Note that the last project---the `"baseline_project"`---is associated with the `"baseline_action"` action. This project has a zero cost and represents the baseline probability of each species persisting if no other project is funded. Finally, although most projects in this example directly relate to a single species, you can input projects that directly affect the persistence of multiple species---you simply need to adjust the species persistence probabilities in the table.

```{r}
# preview first six rows of the table
head(as.data.frame(project_data))
```

Next up, let's look at the `species_data` object. This object stores information about each species in tabular format. Here, each row corresponds to a different species and each column contains information about the species. It contains a `"name"` column that contains the name of each species. Note that these names also appear as column names in the `project_data` object. It also contains a `"weight"` column that denotes the relative importance of each species. These weights were calculated as the evolutionary significance of each species, though they could also reflect cultural or economic importance too.


```{r}
# preview first six rows of the table
head(as.data.frame(species_data))
```

Finally, let's look at the `tree` object. This object stores information about the evolutionary relationships between the simulated species. If you want to read in your own phylogenetic data, check out the [`read.nexus` function from the _ape R_ package](https://www.rdocumentation.org/packages/ape/versions/5.2/topics/read.nexus). Using this object, we can make a plot---specifically, a phylogram---depicting the evolutionary history of our simulated species.

```{r, fig.width = fw, fig.height = fh}
# plot tree
ggtree(tree) +
geom_tiplab(size = 2.5)
```

#### Maximizing expected weighted species richness

Now let's generate some prioritizations using the simulated data. Specifically, we will generate prioritizations using the 'expected weighted species richness' metric. This metric is calculated by multiplying the probability that each species is expected to persist by the species' weight value and summing these values together. It is often used in situations where phylogenetic data are not available. Let us assume that our resources are limited such that we can only spend, at most, $500 on funding conservation projects. In other words, our budget is capped at $500. Now, given the project data (`project_data`), the action data (`action_data`), the species data (`species_data`), and this budget (`500`), we can begin prioritizing funding for the conservation projects. Conventionally, conservation projects have been prioritized using heuristic algorithms [e.g. @r4], so let's generate our first prioritization using this method.

```{r}
# prioritize funding using heuristic algorithm
s1 <- ppp_heuristic_spp_solution(x = project_data, y = action_data,
                                 spp =  species_data, budget = 500,
                                 project_column_name = "name",
                                 success_column_name = "success",
                                 action_column_name = "name",
                                 cost_column_name = "cost",
                                 species_column_name = "name",
                                 weight_column_name = "weight")

# print solution
print(s1)
```

The object `s1` contains the solution and also various statistics associated with the solution in a tabular format (i.e. `tibble`). Here, each row corresponds to a different solution. Specifically, the `"solution"` column contains an identifier for the solution (this is useful for methods that output multiple solutions), the `"objective"` column contains the objective value (i.e. the expected weighted species richness), the `"budget"` column stores the budget used for generating the solution, the `"cost"` column stores the cost of the solution, the `"optimal"` column indicates if the solution is known to be optimal (`NA` values mean the optimality is unknown), and the `"method"` column contains the name of the method used to generate the solution. The remaining columns (`"S1_project"`, `"S2_project"`, `"S3_project"`, ...,  `"S50_project"`, and `"baseline_project"`) indicate if a given project was prioritized for funding (`TRUE`) or not (`FALSE`). To help understand this solution, let's make a plot. The length of the line for each species corresponds to its relative importance.

```{r, message = FALSE, warning = FALSE, fig.width = fw, fig.height = fh}
# visualize solution
ppp_plot_spp_solution(project_data, action_data, species_data, s1,
                      project_column_name = "name",
                      success_column_name = "success",
                      action_column_name = "name",
                      cost_column_name = "cost",
                      species_column_name = "name",
                      weight_column_name = "weight",
                      symbol_hjust = 0.01)
```

In some cases, we might have projects for iconic species that are socially and economically important. To ensure that for projects these species are funded---regardless of cost-efficiency or evolutionary benefit---we can "lock in" certain projects into the solution (conversely, we can also "lock out" certain projects if desired too). Although we could simply increase the weighting for such species, "locking in" such species provides a more transparent method. Let us imagine that it is absolutely critical that the project for species S1 (named `"S1_project"`) receive funding. Let's generate a solution using the heuristic algorithm with this constraint.

```{r}
# set locked in column to only lock in species S3
action_data$locked_in <- action_data$name == "S1_action"

# prioritize funding using heuristic algorithm
s2 <- ppp_heuristic_spp_solution(x = project_data, y = action_data,
                                 spp = species_data, budget = 500,
                                 project_column_name = "name",
                                 success_column_name = "success",
                                 action_column_name = "name",
                                 cost_column_name = "cost",
                                 species_column_name = "name",
                                 weight_column_name = "weight",
                                 locked_in_column_name = "locked_in")

# print solution
print(s2)
```

Let's visualize this new solution with species S1 locked in.

```{r, message = FALSE, warning = FALSE, fig.width = fw, fig.height = fh}
# visualize solution
ppp_plot_spp_solution(project_data, action_data, species_data, s2,
                      project_column_name = "name",
                      success_column_name = "success",
                      action_column_name = "name",
                      cost_column_name = "cost",
                      species_column_name = "name",
                      weight_column_name = "weight",
                      symbol_hjust = 0.01)
```

Next, we might want to evaluate how well this solution compares to funding conservation actions at random. To achieve this, we need to generate solutions that contain randomly selected projects that (i) always include the baseline scenario project, and (ii) meet the budget. Fortunately, the `ppp_random_spp_solution` function does this for us. So, let's generate 1000 random solutions with a budget of $500.

```{r}
# prioritize funding using heuristic algorithm
s3 <- ppp_random_spp_solution(x = project_data, y = action_data,
                              spp = species_data, budget = 500,
                              project_column_name = "name",
                              success_column_name = "success",
                              action_column_name = "name",
                              cost_column_name = "cost",
                              species_column_name = "name",
                              weight_column_name = "weight",
                              locked_in_column_name = "locked_in",
                              number_solutions = 1000)

# print solution
print(s3)
```

Let's visualize the first solution in the set of 1000 randomly generated solutions.

```{r, message = FALSE, warning = FALSE, fig.width = fw, fig.height = fh}
# visualize solution
ppp_plot_spp_solution(project_data, action_data, species_data, s3,
                      project_column_name = "name",
                      success_column_name = "success",
                      action_column_name = "name",
                      cost_column_name = "cost",
                      species_column_name = "name",
                      weight_column_name = "weight",
                      symbol_hjust = 0.01, n = 1)
```

We can now calculate how much better the solution generated using the heuristic algorithm performs compared to randomly funding conservation actions.

```{r}
# calculate how much better solution performs than random
(s2$obj - mean(s3$obj)) / mean(s3$obj)
```

Since the heuristic algorithm performs better than random, you might be tempted to think that the heuristic algorithm is pretty good. But you would be wrong. This is because the heuristic algorithms provide no guarantees on solution quality relative to optimality. This is because objective value associated with a solution tells us how good the solution is, but it does not tell us how good the solution is compared to the best possible solution (i.e. optimality). Therefore we cannot possibly be confident that the solution is any good at all. Fortunately, we can use exact algorithms to find the optimal solution to this problem [for discussion on exact algorithms in conservation, see @r12; @r13].

```{r}
# prioritize funding using stingy heuristic algorithm
s4 <- ppp_exact_spp_solution(x = project_data, y = action_data,
                             spp = species_data, budget = 500,
                             project_column_name = "name",
                             success_column_name = "success",
                             action_column_name = "name",
                             cost_column_name = "cost",
                             species_column_name = "name",
                             weight_column_name = "weight",
                             locked_in_column_name = "locked_in",
                             gap = 0)

# print solution
print(s4)
```

Now let's visualize the optimal solution.

```{r, message = FALSE, warning = FALSE, fig.width = fw, fig.height = fh}
# visualize solution
ppp_plot_spp_solution(project_data, action_data, species_data, s4,
                      project_column_name = "name",
                      success_column_name = "success",
                      action_column_name = "name",
                      cost_column_name = "cost",
                      species_column_name = "name",
                      weight_column_name = "weight",
                      symbol_hjust = 0.01)
```

Now that we have the optimal solution (objective value = `r round(s4$obj, 3)`), we can see that the solution generated by the heuristic algorithm (objective value = `r round(s2$obj, 3)`) was indeed suboptimal.

### Expected phylogenetic diversity

## Citation

Please use the following citation to cite the _optimalppp R_ package in publications:

```{r, echo = FALSE, results = "asis", comment = ""}
cat(paste0("Hanson JO, Schuster R, Strimas-Mackey M, Bennett J, (",format(Sys.time(), "%Y"),"). optimalppp: Optimal Project Prioritization Protocol. R package version ",packageDescription("optimalppp")$Version,". Available at https://github.com/prioritizr/optimalppp.\n"))
```

## References
